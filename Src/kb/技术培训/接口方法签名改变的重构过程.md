# 重构接口
## 由来
当需要改变接口方法的签名（参数）的时候，往往比较麻烦。因为，接口方法的改变代表着所有相关的实现类也要随之而改变。特别是实现类很多的情况下做这样的重构相当麻烦。本文以一个实际的重构为案例探讨了如何让重构能够稳步的迭代的进行，如何减少重构的风险的等问题。
##案例背景：
  ###1.改变接口签名（参数）的重构
  比如 接口方法 function_a(ClassA objectA,ClassB objectB)
  想把这个方法改为 function_a(ClassA objectA,ClassC objectC)
  ###2.原有接口方法的所有实现已经有相应的单元测试。
    任何重构对原有代码是否已有完备的单元测试有很强的依赖性
    2.1.如果老代码没有配备比较完备的测试代码。重构的结局可能很惨，漏洞百出。还有一种可能的情况是开发人员不愿意也不敢重构代码。
    2.2如果代码本身配备有测试代码，那么重构代码会变的轻松很多，而且重构出新bug的风险性也会小很多。
 ###3. 重构的目的
     不是增加新的业务逻辑，而是想改变代码结构，进一步降低代码之间的耦合性。从实现上来说，新接口方法的新参数ClassC 的数据来自于ClassB。重构的目的是 想让ClassC 与原有接口方法function_a解耦合。即把ClassC转换为ClassB的逻辑抽离出来，放到上一层的调用函数中。

## 方案：
###1.方案1：
   ####1.1 方案描述
      比较普遍的做法是直接改变这个接口方法，所有的实现都会报错。然后逐一的让这些编译错误消失。
   ####1.2 方案缺点
    这种重构带来的问题是必须一次改完所有的实现才能提交代码，不好迭代开发。
###2.方案2：
   ####2.1方案描述
      好一点的做法是另外写一个接口，让2个接口方法先并存，然后逐步实现并测试完新的接口方法后再代替原来的接口。
   ####2.2 方案优点
     这样做的好处可以分次提交代码，再逐一测试过每一个新的实现后再用新的接口来替代老接口。
   ####2.3 方案缺点
       重复写测试代码，没有充分利用老的测试代码能检验老的接口方法的优势。
###3.方案3
   ####3.1 方案描述 
     方案2的优点很明显，但是如何利用老测试代码并且避免写额外的测试代码呢。
     我们在重构背景中描述过本案例重构不改变业务逻辑而是想把原有的实现抽离一部分逻辑出来。
     那么可以有的选择是(如下代码)，老的function_a 被重构为2部分，第1部分把需要改变的参数转换为新的参数，第2部分调用新的接口（包含转换后的新的参数）。
     然后把转换代码之后的逻辑 move到新的方法中。
      在修改实现的时候，把新老方法的实现的重构结合起来。
      
    function_a(ClassA objectA,ClassB objectB){
      //从objectB初始化objectC  
       function_a(objectA,objectC);
       }
       function_a(ClassA objectA,ClassC objectC){
    //把原有的逻辑
    }
    ####3.2 方案的优点
       每个实现方法的重构都可以用上述过程，这样老的测试用例能验证是否新的方法是否有效。
   

##实际案例
下面以一个实际的重构为’案例详细描述下重构的流程。

