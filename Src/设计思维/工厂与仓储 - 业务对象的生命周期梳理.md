## 业务对象生命周期
需要一个状态图诠释一下流程： 

创建（内存） ==> 操作 

操作==> 持久化(睡眠）

反持久化(唤醒) ==> 操作 

操作 ==> 销毁(内存和持久层)

## 引入工厂
从业务对象生命周期图中可以明显看出来，创建兑现和持久化是完全不同的阶段，也是完全不同的业务。所以，应该把创建从仓储Repository中分离出来，并且明确的定义一个工厂(Factory)的概念及实现来与仓储并列。

我们目前的系统中，创建业务实际上是在服务层new()一个的，然后就直接用repository保存了，因为从用户的操作来看，很多时候创建业务对象就是为了保存。从而造成了repository直接参与创建业务对象的影响。而实际上,因为工厂这一角色的缺失，创建业务对象的逻辑就没有统一梳理和归纳，而是分散在各个地方，造成混乱。

## 工厂 vs new()
最终工厂会调用某个累的构造器，new()一个新对象出来,从这个角度可以说工厂就是对new()的一个封装。 这里更多是强调他们的区别，也就是引入工厂的原因。
### 工厂是业务概念
工厂是业务概念，强调是创建业务对象(聚合根)；new()是技术概念，系统中还有很多非业务对象和非聚合根业务对象,仍然要用到new(),如果这种情况也使用工厂，就是滥用了，也没有必要。